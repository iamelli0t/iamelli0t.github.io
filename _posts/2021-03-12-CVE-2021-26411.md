---
layout: post
toc: true
title: "CVE-2021-26411: Internet Explorer mshtml use-after-free"
tags: [0day, itw, ie]
author:
  - iamelli0t
---

In January of this year, Google and Microsoft respectively published blogs revealing attacks on security researchers by an APT group in North Korea[1][2]. A vulnerability in Internet Explorer used in this attack was fixed as CVE-2021-26411 in Microsoft's Patch Tuesday this month[3]. The vulnerability is triggered when users of the affected version of Internet Explorer access a malicious link constructed by the attacker, causing remote code execution.

## Root cause analyses
The POC that can trigger the vulnerability is shown below:
```html
<script>
var elem = document.createElement('xxx'); 
var attr1 = document.createAttribute('yyy'); 
var attr2 = document.createAttribute('zzz'); 

var obj = {};
obj.valueOf = function() {
	elem.clearAttributes();
	return 0x1337;
};

attr1.nodeValue = obj;
attr2.nodeValue = 123;
elem.setAttributeNode(attr1);
elem.setAttributeNode(attr2);
elem.removeAttributeNode(attr1); 
</script>
```

Execution process of POC:
1. Create 1 HTML Element object (elem) and 2 HTML Attribute objects (attr1 and attr2)
2. Assign values to the nodeValue of two Attribute objects, where attr1's nodeValue points to an Object which valueOf function is overloaded
3. Bind two Attribute objects attr1 and attr2 to Element object elem
4. Call elem.removeAttributeNode(attr1) to remove the attr1 object from elem
5. The removeAttributeNode method triggers a callback to the valueOf function, during which clearAttributes() is called to clear all the attribute objects bound by the elem object: attr1 and attr2
6. When valueOf callback returns, IE Tab process crashes at null pointer dereference:

![avatar](/_pictures/CVE-2021-26411/1.png)<br><br>

Based on the above PoC flow analysis, it can be inferred that the cause of the crash is the Double Free issue caused by the clearAttributes() function in the valueOf callback. After clearing all the attribute objects bounded by the element object, it returns to the interpreter (breaking the atomic deletion operation at the interpreter level) and frees the attribute object again.<br>
But there are still some details need to be worked out:
1. **Why does removeAttributeNode() trigger the valueOf callback in the script?**
2. **Why does null-pointer dereference exception still occur on DOM objects protected by the ioslated heap and the delayed free mechanism?**
3. **How to exploit this null pointer dereference exception?**

---

Question 1 is discussed through static analysis firstly: <br>

1.The function removeAttributeNode() in mshtml.dll is handled by MSHTML!CElement::ie9_removeAttributeNode function. It calls MSHTML!CElement: : ie9_removeAttributeNodeInternal internally, which is the main implementation of the removeAttributeNode():
![avatar](/_pictures/CVE-2021-26411/2.png)<br><br>

2.MSHTML!CElement::ie9_removeAttributeNodeInternal calls CBase::FindAAIndexNS twice to lookup the indexes of attribute object and attribute nodeValue object in CAttrArray's VARINAT array (+0x8). 
![avatar](/_pictures/CVE-2021-26411/3.png)<br><br>

3.When the index of the attribute object is found, the attribute object is retrieved through CBase::GetObjectAt:
![avatar](/_pictures/CVE-2021-26411/4.png)<br><br>

4.When the nodeValue index of the attribute object is found, it calls CBase::GetIntoBSTRAt function to convert the nodeValue into BSTR and stores the BSTR value to CAttribute.nodeValue (+0x30). **At this time, the valueOf callback will be triggered!**
![avatar](/_pictures/CVE-2021-26411/5.png)<br><br>

5.Then it calls CBase::DeleteAt twice to delete the attribute object and the attribute object nodeValue (here need to pay attention to the existence of one CBase::FindAAIndexNS call in the twice DeleteAt to find the attr1.nodeValue index again):
![avatar](/_pictures/CVE-2021-26411/6.png)<br><br>

6.CBase::DeleteAt firstly checks the index of the object which needs to be deleted. If it is not equal with -1, it calls CAttrArray::Destroy to perform cleanup work:
![avatar](/_pictures/CVE-2021-26411/7.png)<br><br>

7.CAttrArray::Destroy finally calls CImplAry::Delete to modify the CAttrArray counter (+0x4) and sort the corresponding VARIANT array (+0x8) , then calls CAttrValue::Free to release the attribute object:
![avatar](/_pictures/CVE-2021-26411/8.png)<br><br>

----

Then we observe the callback process of problem 1 and analyze problem 2 through dynamic debugging:<br>
1.The memory layout of the elem object before entering the removeAttributeNode function:
![avatar](/_pictures/CVE-2021-26411/9.png)<br><br>


2.The result of two CBase::FindAAIndexNS function calls after entering MSHTML!CElement::ie9_removeAttributeNodeInternal, :
![avatar](/_pictures/CVE-2021-26411/10.png)<br>
![avatar](/_pictures/CVE-2021-26411/11.png)<br><br>


3.CBase::GetIntoBSTRAt triggers the valueOf callback in the script:
![avatar](/_pictures/CVE-2021-26411/12.png)<br><br>


4.The memory layout of the elem object after calling clearAttributes() in the valueOf callback:
![avatar](/_pictures/CVE-2021-26411/13.png)<br><br>

Comparing step 1, you can see that after clearAttributes(), the elem.CAttrArray.count (+0x4) is decremented to 1 and a memory copy operation in CAttrArray VARIANT array (+0x8) happned: the attr2 of index 4 is copied to the previous index in order (shift), which corresponding to the logic of CImplAry::Delete:
![avatar](/_pictures/CVE-2021-26411/14.png)<br><br>


5.When the callback returns, in the the first CBase::DeleteAt() call:<br>
It checks the index of the VARIANT object which waited to be deleted firstly. Here is the attr1 index value 2 which is found in the first CBase::FindAAIndexNS search:
![avatar](/_pictures/CVE-2021-26411/15.png)<br>
After passing the index check, CAttrArray::Destroy is called to start cleaning up.

6.When the callback returns, in the the second CBase::DeleteAt() call:<br>
Recalling the static analysis part, one CBase::FindAAIndexNS between the two CBase::DeleteAt is called to find the attr1.nodeValue index again. Under normal circumstances, CBase::FindAAIndexNS is expected to return 1. However, because the callback breaks the atomic operation at the interpreter level and releases all the attributes of elem in advance, the unexpected -1 is returned here:
![avatar](/_pictures/CVE-2021-26411/16.png)<br><br>

According to the static analysis of the CBase::DeleteAt function, for the case where the index is -1, an exception will be thrown:
![avatar](/_pictures/CVE-2021-26411/17.png)<br><br>

After returning, the CAttrArray object pointer points to the memory set as NULL, which finally triggers the null pointer dereference exception:
![avatar](/_pictures/CVE-2021-26411/18.png)<br><br>

Here is a picture to explain the whole process:
![avatar](/_pictures/CVE-2021-26411/19.png)<br><br>

## From null pointer dereference to read/write primitive


## Some thoughts


## References
[1] https://blog.google/threat-analysis-group/new-campaign-targeting-security-researchers/<br>
[2] https://www.microsoft.com/security/blog/2021/01/28/zinc-attacks-against-security-researchers/<br>
[3] https://msrc.microsoft.com/update-guide/en-us/vulnerability/CVE-2021-26411<br>
[4] https://enki.co.kr/blog/2021/02/04/ie_0day.html<br>
